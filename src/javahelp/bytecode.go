// Copyright by Volodymyr Dobryvechir 2019 (dobrivecher@yahoo.com, vdobryvechir@gmail.com)

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
)

type ByteCodeItem struct {
	code        int
	operation   string
	description string
}

var copyright = "Copyright by Volodymyr Dobryvechir 2019"

var byteCodeTable = []ByteCodeItem{
	ByteCodeItem{"code": 0x32, "operation": "aaload", "description": "arrayref, index → value load onto the stack a reference from an array"},
	ByteCodeItem{"code": 0x53, "operation": "aastore", "description": "arrayref, index, value → store a reference in an array"},
	ByteCodeItem{"code": 0x01, "operation": "aconst_null", "description": "→ null push a null reference onto the stack"},
	ByteCodeItem{"code": 0x19, "operation": "aload", "description": ": index → objectref load a reference onto the stack from a local variable #index"},
	ByteCodeItem{"code": 0x2a, "operation": "aload_0", "description": "→ objectref load a reference onto the stack from local variable 0"},
	ByteCodeItem{"code": 0x2b, "operation": "aload_1", "description": "→ objectref load a reference onto the stack from local variable 1"},
	ByteCodeItem{"code": 0x2c, "operation": "aload_2", "description": "→ objectref load a reference onto the stack from local variable 2"},
	ByteCodeItem{"code": 0x2d, "operation": "aload_3", "description": "→ objectref load a reference onto the stack from local variable 3"},
	ByteCodeItem{"code": 0xbd, "operation": "anewarray", "description": "2: indexbyte1, indexbyte2 count → arrayref create a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool"},
	ByteCodeItem{"code": 0xb0, "operation": "areturn", "description": "objectref → [empty] return a reference from a method"},
	ByteCodeItem{"code": 0xbe, "operation": "arraylength", "description": "arrayref → length get the length of an array"},
	ByteCodeItem{"code": 0x3a, "operation": "astore", "description": ": index objectref → store a reference into a local variable #index"},
	ByteCodeItem{"code": 0x4b, "operation": "astore_0", "description": "objectref → store a reference into local variable 0"},
	ByteCodeItem{"code": 0x4c, "operation": "astore_1", "description": "objectref → store a reference into local variable 1"},
	ByteCodeItem{"code": 0x4d, "operation": "astore_2", "description": "objectref → store a reference into local variable 2"},
	ByteCodeItem{"code": 0x4e, "operation": "astore_3", "description": "objectref → store a reference into local variable 3"},
	ByteCodeItem{"code": 0xbf, "operation": "athrow", "description": "objectref → [empty], objectref throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)"},
	ByteCodeItem{"code": 0x33, "operation": "baload", "description": "arrayref, index → value load a byte or Boolean value from an array"},
	ByteCodeItem{"code": 0x54, "operation": "bastore", "description": "arrayref, index, value → store a byte or Boolean value into an array"},
	ByteCodeItem{"code": 0x10, "operation": "bipush", "description": ": byte → value push a byte onto the stack as an integer value"},
	ByteCodeItem{"code": 0xca, "operation": "breakpoint", "description": "reserved for breakpoints in Java debuggers; should not appear in any class file"},
	ByteCodeItem{"code": 0x34, "operation": "caload", "description": "arrayref, index → value load a char from an array"},
	ByteCodeItem{"code": 0x55, "operation": "castore", "description": "arrayref, index, value → store a char into an array"},
	ByteCodeItem{"code": 0xc0, "operation": "checkcast", "description": "2: indexbyte1, indexbyte2 objectref → objectref checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0x90, "operation": "d2f", "description": "value → result convert a double to a float"},
	ByteCodeItem{"code": 0x8e, "operation": "d2i", "description": "value → result convert a double to an int"},
	ByteCodeItem{"code": 0x8f, "operation": "d2l", "description": "value → result convert a double to a long"},
	ByteCodeItem{"code": 0x63, "operation": "dadd", "description": "value1, value2 → result add two doubles"},
	ByteCodeItem{"code": 0x31, "operation": "daload", "description": "arrayref, index → value load a double from an array"},
	ByteCodeItem{"code": 0x52, "operation": "dastore", "description": "arrayref, index, value → store a double into an array"},
	ByteCodeItem{"code": 0x98, "operation": "dcmpg", "description": "value1, value2 → result compare two doubles"},
	ByteCodeItem{"code": 0x97, "operation": "dcmpl", "description": "value1, value2 → result compare two doubles"},
	ByteCodeItem{"code": 0x0e, "operation": "dconst_0", "description": "→ 0.0 push the constant 0.0 (a double) onto the stack"},
	ByteCodeItem{"code": 0x0f, "operation": "dconst_1", "description": "→ 1.0 push the constant 1.0 (a double) onto the stack"},
	ByteCodeItem{"code": 0x6f, "operation": "ddiv", "description": "value1, value2 → result divide two doubles"},
	ByteCodeItem{"code": 0x18, "operation": "dload", "description": ": index → value load a double value from a local variable #index"},
	ByteCodeItem{"code": 0x26, "operation": "dload_0", "description": "→ value load a double from local variable 0"},
	ByteCodeItem{"code": 0x27, "operation": "dload_1", "description": "→ value load a double from local variable 1"},
	ByteCodeItem{"code": 0x28, "operation": "dload_2", "description": "→ value load a double from local variable 2"},
	ByteCodeItem{"code": 0x29, "operation": "dload_3", "description": "→ value load a double from local variable 3"},
	ByteCodeItem{"code": 0x6b, "operation": "dmul", "description": "value1, value2 → result multiply two doubles"},
	ByteCodeItem{"code": 0x77, "operation": "dneg", "description": "value → result negate a double"},
	ByteCodeItem{"code": 0x73, "operation": "drem", "description": "value1, value2 → result get the remainder from a division between two doubles"},
	ByteCodeItem{"code": 0xaf, "operation": "dreturn", "description": "value → [empty] return a double from a method"},
	ByteCodeItem{"code": 0x39, "operation": "dstore", "description": ": index value → store a double value into a local variable #index"},
	ByteCodeItem{"code": 0x47, "operation": "dstore_0", "description": "value → store a double into local variable 0"},
	ByteCodeItem{"code": 0x48, "operation": "dstore_1", "description": "value → store a double into local variable 1"},
	ByteCodeItem{"code": 0x49, "operation": "dstore_2", "description": "value → store a double into local variable 2"},
	ByteCodeItem{"code": 0x4a, "operation": "dstore_3", "description": "value → store a double into local variable 3"},
	ByteCodeItem{"code": 0x67, "operation": "dsub", "description": "value1, value2 → result subtract a double from another"},
	ByteCodeItem{"code": 0x59, "operation": "dup", "description": "value → value, value duplicate the value on top of the stack"},
	ByteCodeItem{"code": 0x5a, "operation": "dup_x1", "description": "value2, value1 → value1, value2, value1 insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type double or long."},
	ByteCodeItem{"code": 0x5b, "operation": "dup_x2", "description": "value3, value2, value1 → value1, value3, value2, value1 insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top"},
	ByteCodeItem{"code": 0x5c, "operation": "dup2", "description": "{value2, value1} → {value2, value1}, {value2, value1} duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)"},
	ByteCodeItem{"code": 0x5d, "operation": "dup2_x1", "description": "value3, {value2, value1} → {value2, value1}, value3, {value2, value1} duplicate two words and insert beneath third word (see explanation above)"},
	ByteCodeItem{"code": 0x5e, "operation": "dup2_x2", "description": "{value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1} duplicate two words and insert beneath fourth word"},
	ByteCodeItem{"code": 0x8d, "operation": "f2d", "description": "value → result convert a float to a double"},
	ByteCodeItem{"code": 0x8b, "operation": "f2i", "description": "value → result convert a float to an int"},
	ByteCodeItem{"code": 0x8c, "operation": "f2l", "description": "value → result convert a float to a long"},
	ByteCodeItem{"code": 0x62, "operation": "fadd", "description": "value1, value2 → result add two floats"},
	ByteCodeItem{"code": 0x30, "operation": "faload", "description": "arrayref, index → value load a float from an array"},
	ByteCodeItem{"code": 0x51, "operation": "fastore", "description": "arrayref, index, value → store a float in an array"},
	ByteCodeItem{"code": 0x96, "operation": "fcmpg", "description": "value1, value2 → result compare two floats"},
	ByteCodeItem{"code": 0x95, "operation": "fcmpl", "description": "value1, value2 → result compare two floats"},
	ByteCodeItem{"code": 0x0b, "operation": "fconst_0", "description": "→ 0.0f push 0.0f on the stack"},
	ByteCodeItem{"code": 0x0c, "operation": "fconst_1", "description": "→ 1.0f push 1.0f on the stack"},
	ByteCodeItem{"code": 0x0d, "operation": "fconst_2", "description": "→ 2.0f push 2.0f on the stack"},
	ByteCodeItem{"code": 0x6e, "operation": "fdiv", "description": "value1, value2 → result divide two floats"},
	ByteCodeItem{"code": 0x17, "operation": "fload", "description": ": index → value load a float value from a local variable #index"},
	ByteCodeItem{"code": 0x22, "operation": "fload_0", "description": "→ value load a float value from local variable 0"},
	ByteCodeItem{"code": 0x23, "operation": "fload_1", "description": "→ value load a float value from local variable 1"},
	ByteCodeItem{"code": 0x24, "operation": "fload_2", "description": "→ value load a float value from local variable 2"},
	ByteCodeItem{"code": 0x25, "operation": "fload_3", "description": "→ value load a float value from local variable 3"},
	ByteCodeItem{"code": 0x6a, "operation": "fmul", "description": "value1, value2 → result multiply two floats"},
	ByteCodeItem{"code": 0x76, "operation": "fneg", "description": "value → result negate a float"},
	ByteCodeItem{"code": 0x72, "operation": "frem", "description": "value1, value2 → result get the remainder from a division between two floats"},
	ByteCodeItem{"code": 0xae, "operation": "freturn", "description": "value → [empty] return a float"},
	ByteCodeItem{"code": 0x38, "operation": "fstore", "description": ": index value → store a float value into a local variable #index"},
	ByteCodeItem{"code": 0x43, "operation": "fstore_0", "description": "value → store a float value into local variable 0"},
	ByteCodeItem{"code": 0x44, "operation": "fstore_1", "description": "value → store a float value into local variable 1"},
	ByteCodeItem{"code": 0x45, "operation": "fstore_2", "description": "value → store a float value into local variable 2"},
	ByteCodeItem{"code": 0x46, "operation": "fstore_3", "description": "value → store a float value into local variable 3"},
	ByteCodeItem{"code": 0x66, "operation": "fsub", "description": "value1, value2 → result subtract two floats"},
	ByteCodeItem{"code": 0xb4, "operation": "getfield", "description": "2: indexbyte1, indexbyte2 objectref → value get a field value of an object objectref, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb2, "operation": "getstatic", "description": "2: indexbyte1, indexbyte2 → value get a static field value of a class, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xa7, "operation": "goto", "description": "2: branchbyte1, branchbyte2 [no change] goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xc8, "operation": "goto_w", "description": "4: branchbyte1, branchbyte2, branchbyte3, branchbyte4 [no change] goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)"},
	ByteCodeItem{"code": 0x91, "operation": "i2b", "description": "value → result convert an int into a byte"},
	ByteCodeItem{"code": 0x92, "operation": "i2c", "description": "value → result convert an int into a character"},
	ByteCodeItem{"code": 0x87, "operation": "i2d", "description": "value → result convert an int into a double"},
	ByteCodeItem{"code": 0x86, "operation": "i2f", "description": "value → result convert an int into a float"},
	ByteCodeItem{"code": 0x85, "operation": "i2l", "description": "value → result convert an int into a long"},
	ByteCodeItem{"code": 0x93, "operation": "i2s", "description": "value → result convert an int into a short"},
	ByteCodeItem{"code": 0x60, "operation": "iadd", "description": "value1, value2 → result add two ints"},
	ByteCodeItem{"code": 0x2e, "operation": "iaload", "description": "arrayref, index → value load an int from an array"},
	ByteCodeItem{"code": 0x7e, "operation": "iand", "description": "value1, value2 → result perform a bitwise AND on two integers"},
	ByteCodeItem{"code": 0x4f, "operation": "iastore", "description": "arrayref, index, value → store an int into an array"},
	ByteCodeItem{"code": 0x02, "operation": "iconst_m1", "description": "→ -1 load the int value −1 onto the stack"},
	ByteCodeItem{"code": 0x03, "operation": "iconst_0", "description": "→ 0 load the int value 0 onto the stack"},
	ByteCodeItem{"code": 0x04, "operation": "iconst_1", "description": "→ 1 load the int value 1 onto the stack"},
	ByteCodeItem{"code": 0x05, "operation": "iconst_2", "description": "→ 2 load the int value 2 onto the stack"},
	ByteCodeItem{"code": 0x06, "operation": "iconst_3", "description": "→ 3 load the int value 3 onto the stack"},
	ByteCodeItem{"code": 0x07, "operation": "iconst_4", "description": "→ 4 load the int value 4 onto the stack"},
	ByteCodeItem{"code": 0x08, "operation": "iconst_5", "description": "→ 5 load the int value 5 onto the stack"},
	ByteCodeItem{"code": 0x6c, "operation": "idiv", "description": "value1, value2 → result divide two integers"},
	ByteCodeItem{"code": 0xa5, "operation": "if_acmpeq", "description": "2: branchbyte1, branchbyte2 value1, value2 → if references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa6, "operation": "if_acmpne", "description": "2: branchbyte1, branchbyte2 value1, value2 → if references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9f, "operation": "if_icmpeq", "description": "2: branchbyte1, branchbyte2 value1, value2 → if ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa2, "operation": "if_icmpge", "description": "2: branchbyte1, branchbyte2 value1, value2 → if value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa3, "operation": "if_icmpgt", "description": "2: branchbyte1, branchbyte2 value1, value2 → if value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa4, "operation": "if_icmple", "description": "2: branchbyte1, branchbyte2 value1, value2 → if value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa1, "operation": "if_icmplt", "description": "2: branchbyte1, branchbyte2 value1, value2 → if value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xa0, "operation": "if_icmpne", "description": "2: branchbyte1, branchbyte2 value1, value2 → if ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x99, "operation": "ifeq", "description": "2: branchbyte1, branchbyte2 value → if value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9c, "operation": "ifge", "description": "2: branchbyte1, branchbyte2 value → if value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9d, "operation": "ifgt", "description": "2: branchbyte1, branchbyte2 value → if value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9e, "operation": "ifle", "description": "2: branchbyte1, branchbyte2 value → if value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9b, "operation": "iflt", "description": "2: branchbyte1, branchbyte2 value → if value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x9a, "operation": "ifne", "description": "2: branchbyte1, branchbyte2 value → if value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xc7, "operation": "ifnonnull", "description": "2: branchbyte1, branchbyte2 value → if value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0xc6, "operation": "ifnull", "description": "2: branchbyte1, branchbyte2 value → if value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)"},
	ByteCodeItem{"code": 0x84, "operation": "iinc", "description": "2: index, const [No change] increment local variable #index by signed byte const"},
	ByteCodeItem{"code": 0x15, "operation": "iload", "description": ": index → value load an int value from a local variable #index"},
	ByteCodeItem{"code": 0x1a, "operation": "iload_0", "description": "→ value load an int value from local variable 0"},
	ByteCodeItem{"code": 0x1b, "operation": "iload_1", "description": "→ value load an int value from local variable 1"},
	ByteCodeItem{"code": 0x1c, "operation": "iload_2", "description": "→ value load an int value from local variable 2"},
	ByteCodeItem{"code": 0x1d, "operation": "iload_3", "description": "→ value load an int value from local variable 3"},
	ByteCodeItem{"code": 0xfe, "operation": "impdep1", "description": "reserved for implementation-dependent operations within debuggers; should not appear in any class file"},
	ByteCodeItem{"code": 0xff, "operation": "impdep2", "description": "reserved for implementation-dependent operations within debuggers; should not appear in any class file"},
	ByteCodeItem{"code": 0x68, "operation": "imul", "description": "value1, value2 → result multiply two integers"},
	ByteCodeItem{"code": 0x74, "operation": "ineg", "description": "value → result negate int"},
	ByteCodeItem{"code": 0xc1, "operation": "instanceof", "description": "2: indexbyte1, indexbyte2 objectref → result determines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xba, "operation": "invokedynamic", "description": "4: indexbyte1, indexbyte2, 0, 0 [arg1, [arg2 ...]] → result invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb9, "operation": "invokeinterface", "description": "4: indexbyte1, indexbyte2, count, 0 objectref, [arg1, arg2, ...] → result invokes an interface method on object objectref and puts the result on the stack (might be void); the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb7, "operation": "invokespecial", "description": "2: indexbyte1, indexbyte2 objectref, [arg1, arg2, ...] → result invoke instance method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb8, "operation": "invokestatic", "description": "2: indexbyte1, indexbyte2 [arg1, arg2, ...] → result invoke a static method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb6, "operation": "invokevirtual", "description": "2: indexbyte1, indexbyte2 objectref, [arg1, arg2, ...] → result invoke virtual method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0x80, "operation": "ior", "description": "value1, value2 → result bitwise int OR"},
	ByteCodeItem{"code": 0x70, "operation": "irem", "description": "value1, value2 → result logical int remainder"},
	ByteCodeItem{"code": 0xac, "operation": "ireturn", "description": "value → [empty] return an integer from a method"},
	ByteCodeItem{"code": 0x78, "operation": "ishl", "description": "value1, value2 → result int shift left"},
	ByteCodeItem{"code": 0x7a, "operation": "ishr", "description": "value1, value2 → result int arithmetic shift right"},
	ByteCodeItem{"code": 0x36, "operation": "istore", "description": ": index value → store int value into variable #index"},
	ByteCodeItem{"code": 0x3b, "operation": "istore_0", "description": "value → store int value into variable 0"},
	ByteCodeItem{"code": 0x3c, "operation": "istore_1", "description": "value → store int value into variable 1"},
	ByteCodeItem{"code": 0x3d, "operation": "istore_2", "description": "value → store int value into variable 2"},
	ByteCodeItem{"code": 0x3e, "operation": "istore_3", "description": "value → store int value into variable 3"},
	ByteCodeItem{"code": 0x64, "operation": "isub", "description": "value1, value2 → result int subtract"},
	ByteCodeItem{"code": 0x7c, "operation": "iushr", "description": "value1, value2 → result int logical shift right"},
	ByteCodeItem{"code": 0x82, "operation": "ixor", "description": "value1, value2 → result int xor"},
	ByteCodeItem{"code": 0xa8, "operation": "jsr", "description": "2: branchbyte1, branchbyte2 → address jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack"},
	ByteCodeItem{"code": 0xc9, "operation": "jsr_w", "description": "4: branchbyte1, branchbyte2, branchbyte3, branchbyte4 → address jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack"},
	ByteCodeItem{"code": 0x8a, "operation": "l2d", "description": "value → result convert a long to a double"},
	ByteCodeItem{"code": 0x89, "operation": "l2f", "description": "value → result convert a long to a float"},
	ByteCodeItem{"code": 0x88, "operation": "l2i", "description": "value → result convert a long to a int"},
	ByteCodeItem{"code": 0x61, "operation": "ladd", "description": "value1, value2 → result add two longs"},
	ByteCodeItem{"code": 0x2f, "operation": "laload", "description": "arrayref, index → value load a long from an array"},
	ByteCodeItem{"code": 0x7f, "operation": "land", "description": "value1, value2 → result bitwise AND of two longs"},
	ByteCodeItem{"code": 0x50, "operation": "lastore", "description": "arrayref, index, value → store a long to an array"},
	ByteCodeItem{"code": 0x94, "operation": "lcmp", "description": "value1, value2 → result push 0 if the two longs are the same, 1 if value1 is greater than value2, -1 otherwise"},
	ByteCodeItem{"code": 0x09, "operation": "lconst_0", "description": "→ 0L push 0L (the number zero with type long) onto the stack"},
	ByteCodeItem{"code": 0x0a, "operation": "lconst_1", "description": "→ 1L push 1L (the number one with type long) onto the stack"},
	ByteCodeItem{"code": 0x12, "operation": "ldc", "description": ": index → value push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack"},
	ByteCodeItem{"code": 0x13, "operation": "ldc_w", "description": "2: indexbyte1, indexbyte2 → value push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0x14, "operation": "ldc2_w", "description": "2: indexbyte1, indexbyte2 → value push a constant #index from a constant pool (double, long, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0x6d, "operation": "ldiv", "description": "value1, value2 → result divide two longs"},
	ByteCodeItem{"code": 0x16, "operation": "lload", "description": ": index → value load a long value from a local variable #index"},
	ByteCodeItem{"code": 0x1e, "operation": "lload_0", "description": "→ value load a long value from a local variable 0"},
	ByteCodeItem{"code": 0x1f, "operation": "lload_1", "description": "→ value load a long value from a local variable 1"},
	ByteCodeItem{"code": 0x20, "operation": "lload_2", "description": "→ value load a long value from a local variable 2"},
	ByteCodeItem{"code": 0x21, "operation": "lload_3", "description": "→ value load a long value from a local variable 3"},
	ByteCodeItem{"code": 0x69, "operation": "lmul", "description": "value1, value2 → result multiply two longs"},
	ByteCodeItem{"code": 0x75, "operation": "lneg", "description": "value → result negate a long"},
	ByteCodeItem{"code": 0xab, "operation": "lookupswitch", "description": "8+: <0–3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs... key → a target address is looked up from a table using a key and execution continues from the instruction at that address"},
	ByteCodeItem{"code": 0x81, "operation": "lor", "description": "value1, value2 → result bitwise OR of two longs"},
	ByteCodeItem{"code": 0x71, "operation": "lrem", "description": "value1, value2 → result remainder of division of two longs"},
	ByteCodeItem{"code": 0xad, "operation": "lreturn", "description": "value → [empty] return a long value"},
	ByteCodeItem{"code": 0x79, "operation": "lshl", "description": "value1, value2 → result bitwise shift left of a long value1 by int value2 positions"},
	ByteCodeItem{"code": 0x7b, "operation": "lshr", "description": "value1, value2 → result bitwise shift right of a long value1 by int value2 positions"},
	ByteCodeItem{"code": 0x37, "operation": "lstore", "description": ": index value → store a long value in a local variable #index"},
	ByteCodeItem{"code": 0x3f, "operation": "lstore_0", "description": "value → store a long value in a local variable 0"},
	ByteCodeItem{"code": 0x40, "operation": "lstore_1", "description": "value → store a long value in a local variable 1"},
	ByteCodeItem{"code": 0x41, "operation": "lstore_2", "description": "value → store a long value in a local variable 2"},
	ByteCodeItem{"code": 0x42, "operation": "lstore_3", "description": "value → store a long value in a local variable 3"},
	ByteCodeItem{"code": 0x65, "operation": "lsub", "description": "value1, value2 → result subtract two longs"},
	ByteCodeItem{"code": 0x7d, "operation": "lushr", "description": "value1, value2 → result bitwise shift right of a long value1 by int value2 positions, unsigned"},
	ByteCodeItem{"code": 0x83, "operation": "lxor", "description": "value1, value2 → result bitwise XOR of two longs"},
	ByteCodeItem{"code": 0xc2, "operation": "monitorenter", "description": "objectref → enter monitor for object (\"grab the lock\" – start of synchronized() section)"},
	ByteCodeItem{"code": 0xc3, "operation": "monitorexit", "description": "objectref → exit monitor for object (\"release the lock\" – end of synchronized() section)"},
	ByteCodeItem{"code": 0xc5, "operation": "multianewarray", "description": "3: indexbyte1, indexbyte2, dimensions count1, [count2,...] → arrayref create a new array of dimensions dimensions of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.]"},
	ByteCodeItem{"code": 0xbb, "operation": "new", "description": "2: indexbyte1, indexbyte2 → objectref create new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xbc, "operation": "newarray", "description": ": atype count → arrayref create new array with count elements of primitive type identified by atype"},
	ByteCodeItem{"code": 0x00, "operation": "nop", "description": "[No change] perform no operation"},
	ByteCodeItem{"code": 0x57, "operation": "pop", "description": "value → discard the top value on the stack"},
	ByteCodeItem{"code": 0x58, "operation": "pop2", "description": "{value2, value1} → discard the top two values on the stack (or one value, if it is a double or long)"},
	ByteCodeItem{"code": 0xb5, "operation": "putfield", "description": "2: indexbyte1, indexbyte2 objectref, value → set field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xb3, "operation": "putstatic", "description": "2: indexbyte1, indexbyte2 value → set static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)"},
	ByteCodeItem{"code": 0xa9, "operation": "ret", "description": ": index [No change] continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)"},
	ByteCodeItem{"code": 0xb1, "operation": "return", "description": "→ [empty] return void from method"},
	ByteCodeItem{"code": 0x35, "operation": "saload", "description": "arrayref, index → value load short from array"},
	ByteCodeItem{"code": 0x56, "operation": "sastore", "description": "arrayref, index, value → store short to array"},
	ByteCodeItem{"code": 0x11, "operation": "sipush", "description": "2: byte1, byte2 → value push a short onto the stack as an integer value"},
	ByteCodeItem{"code": 0x5f, "operation": "swap", "description": "value2, value1 → value1, value2 swaps two top words on the stack (note that value1 and value2 must not be double or long)"},
	ByteCodeItem{"code": 0xaa, "operation": "tableswitch", "description": "6+: [0–3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets... index → continue execution from an address in the table at offset index"},
	ByteCodeItem{"code": 0xc4, "operation": "wide", "description": "3/5: opcode, indexbyte1, indexbyte2"},
}
